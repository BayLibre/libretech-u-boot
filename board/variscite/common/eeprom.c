/*
 * Copyright (C) 2016 BayLibre, SAS
 * Author: Neil Armstrong <narmstrong@baylibre.com>
 *
 * Copyright (C) 2016 Variscite Ltd. All Rights Reserved.
 *
 * SPDX-License-Identifier:	GPL-2.0+
 */

#include <common.h>
#include <i2c.h>
#include "eeprom_private.h"

#define VARISCITE_MAGIC_V2		0x32524156 /* == HEX("VAR2") */

#define VAR_DART_EEPROM_I2C_BUS		0
#define VAR_DART_EEPROM_I2C_ADDR	0x52

#define WHILE_NOT_EQUAL_INDEX		241
#define WHILE_EQUAL_INDEX		242
#define WHILE_AND_INDEX			243
#define WHILE_NOT_AND_INDEX		244
#define DELAY_10USEC_INDEX		245
#define LAST_COMMAND_INDEX		255

#define MAX_CUSTOM_ADDRESSES		32
#define MAX_CUSTOM_VALUES		32

#define MAX_COMMON_ADDRS_INDEX		200
#define MAX_COMMON_VALUES_INDEX		200

#define MAX_NUM_OF_COMMANDS		150

struct __attribute__((packed)) eeprom_command
{
	u8 address_index;
	u8 value_index;
};

struct __attribute__((packed)) eeprom_cfg
{
	u32 variscite_magic; /* == HEX("VAR2")? */
	u8 part_number[16];
	u8 Assembly[16];
	u8 date[12];

	/* Contains addresses and values not present in .inc files */
	u32 custom_addresses_values[32];
	struct eeprom_command commands[MAX_NUM_OF_COMMANDS];
	u8 reserved[34];

	/* DRAM size in 8KiB unit */
	u8 dram_size;
	u8 crc;
};

static int dart_mx6_eeprom_read_struct(struct eeprom_cfg *eeprom_cfg)
{
	i2c_set_bus_num(VAR_DART_EEPROM_I2C_BUS);

	if (i2c_probe(VAR_DART_EEPROM_I2C_ADDR)) {
		printf("Error: Couldn't find EEPROM device\n");
		return -1;
	}

	if (i2c_read(VAR_DART_EEPROM_I2C_ADDR, 0, 1,
				(u8 *) eeprom_cfg,
				sizeof(struct eeprom_cfg))) {
		printf("Error reading data from EEPROM\n");
		return -1;
	}

	if (VARISCITE_MAGIC_V2 != eeprom_cfg->variscite_magic) {
		printf("Error: Data on EEPROM is invalid\n");
		return -1;
	}

	return 0;
}

/*
 * Fills custom_addresses & custom_values, from custom_addresses_values
 */
static void dart_mx6_load_custom_data(u32 *custom_addresses,
				      u32 *custom_values,
				      const u32 *custom_addresses_values)
{
	int i, j;

	for (i = 0; i < MAX_CUSTOM_ADDRESSES; i++) {
		if (custom_addresses_values[i] == 0)
			break;
		custom_addresses[i] = custom_addresses_values[i];
	}

	i++;
	if (i > MAX_CUSTOM_ADDRESSES)
		return;

	j = 0;
	for (; i < MAX_CUSTOM_VALUES; i++) {
		if (custom_addresses_values[i] == 0)
			break;
		custom_values[j] = custom_addresses_values[i];
		j++;
	}
}

static u32 dart_mx6_get_address_by_index(u8 index,
					 const u32 *common_addresses,
					 const u32 *custom_addresses)
{
	if (index >= MAX_COMMON_ADDRS_INDEX)
		return custom_addresses[index - MAX_COMMON_ADDRS_INDEX];

	return common_addresses[index];
}

static u32 dart_mx6_get_value_by_index(u8 index,
				       const u32 *common_values,
				       const u32 *custom_values)
{
	if (index >= MAX_COMMON_VALUES_INDEX)
		return custom_values[index - MAX_COMMON_VALUES_INDEX];

	return common_values[index];
}

static int dart_mx6_handle_commands(const struct eeprom_command commands[],
				    const u32 *common_addresses,
				    const u32 *common_values,
				    const u32 *custom_addresses,
				    const u32 *custom_values)
{
	u32 address, value;
	volatile u32 *reg_ptr;
	u8 wait_idx = 0;
	int i = 0;

	while (i < MAX_NUM_OF_COMMANDS) {
		if (commands[i].address_index == LAST_COMMAND_INDEX)
			return 0;

		if (commands[i].address_index == DELAY_10USEC_INDEX) {
			/* Delay for Value * 10 uSeconds */
			udelay((int)(commands[i].value_index * 10));
			++i;
			continue;
		}

		/*
		 * Check for a wait index.
		 * A wait index means "next command is a wait command".
		 */
		switch (commands[i].address_index) {
		case WHILE_NOT_EQUAL_INDEX:
		case WHILE_EQUAL_INDEX:
		case WHILE_AND_INDEX:
		case WHILE_NOT_AND_INDEX:
			/* Save wait index and go to next command */
			wait_idx = commands[i].address_index;
			++i;
			break;
		}

		/* Get address and value */
		address = dart_mx6_get_address_by_index(
				commands[i].address_index,
				common_addresses,
				custom_addresses);
		value = dart_mx6_get_value_by_index(
				commands[i].value_index,
				common_values,
				custom_values);
		reg_ptr = (u32 *)address;

		switch (wait_idx) {
		case WHILE_NOT_EQUAL_INDEX:
			/* Waiting while data at address is not equal */
			while(*reg_ptr != value);
			break;
		case WHILE_EQUAL_INDEX:
			/* Waiting while data at address is equal */
			while(*reg_ptr == value);
			break;
		case WHILE_AND_INDEX:
			/* Waiting while data at address is not zero */
			while(*reg_ptr & value);
			break;
		case WHILE_NOT_AND_INDEX:
			/* Waiting while data at address is zero */
			while(!(*reg_ptr & value));
			break;
		default:
			/* This is a regular set command (non-wait) */
			*reg_ptr = value;
			break;
		}

		++i;
	}

	return 0;
}

/*
 * This is an automatically generated part.
 */
static unsigned char MX6Q_MMDC_LPDDR2_register_programming_aid_v0_Micron_InterL_commands[]={
	0x01, 0x9B,	0x02, 0x9B,	0x03, 0x9B,	0x04, 0x9B,
	0x05, 0x9B,	0x06, 0x9B,	0x07, 0x9B,	0x42, 0x1C,
	0x3D, 0x00,	0x2C, 0x07,	0x2E, 0x07,	0x29, 0x07,
	0x2A, 0x07,	0x2B, 0x07,	0x2D, 0x00,	0x2F, 0x07,
	0x30, 0x07,	0x3A, 0x07,	0x48, 0x07,	0x3B, 0x1C,
	0x31, 0x13,	0x33, 0x13,	0x27, 0x13,	0x25, 0x13,
	0x24, 0x13,	0x21, 0x13,	0x35, 0x13,	0x37, 0x13,
	0x4A, 0x26,	0x46, 0x07,	0x47, 0x07,	0x49, 0x07,
	0x4B, 0x07,	0x4C, 0x07,	0x4D, 0x07,	0x4E, 0x07,
	0x39, 0x07,	0x32, 0x07,	0x34, 0x07,	0x28, 0x07,
	0x26, 0x07,	0x23, 0x07,	0x22, 0x07,	0x36, 0x07,
	0x38, 0x07,	0xC8, 0xC8,	0xC9, 0xC9,	0x56, 0x16,
	0x79, 0x16,	0x6E, 0x66,	0x91, 0x66,	0x5E, 0x90,
	0x81, 0x90,	0x6F, 0x3A,	0x92, 0x3A,	0x62, 0x6C,
	0x63, 0xCA,	0x64, 0x6C,	0x65, 0x6C,	0x85, 0x6C,
	0x86, 0x6C,	0x87, 0x6C,	0x88, 0x6C,	0x66, 0x97,
	0x67, 0xCA,	0x68, 0x97,	0x69, 0x97,	0x89, 0x97,
	0x8A, 0x97,	0x8B, 0x97,	0x8C, 0x97,	0x70, 0x0D,
	0x93, 0x0D,	0x6C, 0xCB,	0x8F, 0xCC,	0x6D, 0xCD,
	0x90, 0xCE,	0x6A, 0x67,	0x6B, 0x00,	0x8D, 0x67,
	0x8E, 0x00,	0x71, 0x69,	0x95, 0x69,	0x52, 0xCF,
	0x50, 0x1F,	0x53, 0xD0,	0x54, 0xD1,	0x55, 0x0F,
	0x58, 0xD2,	0x59, 0xD3,	0x5A, 0xD4,	0x51, 0x00,
	0x5B, 0x09,	0x5C, 0x61,	0x4F, 0x8B,	0x75, 0xCF,
	0x73, 0x1F,	0x76, 0xD0,	0x77, 0xD1,	0x78, 0x0F,
	0x7B, 0xD2,	0x7C, 0xD3,	0x7D, 0xD4,	0x74, 0x00,
	0x7E, 0x02,	0x7F, 0x61,	0x72, 0x8B,	0x56, 0x38,
	0x56, 0x98,	0x56, 0x93,	0x56, 0x5B,	0x56, 0x45,
	0x79, 0x38,	0x79, 0x98,	0x79, 0x93,	0x79, 0x5B,
	0x79, 0x45,	0x5E, 0x90,	0x57, 0xD5,	0x7A, 0xD5,
	0x61, 0x00,	0x84, 0x00,	0x50, 0x23,	0x73, 0x23,
	0x5D, 0x19,	0x80, 0x19,	0x56, 0x00,	0x79, 0x00,
	0xFF, 0xFF
};
/* End of automatically generated part */

/*
 * This is an automatically generated part.
 * Address file was: addresses.inc
 * Address file MD5 was: 980A738D4534913CD453034EBE23D4EA
 * Values file was: values.inc
 * Values file MD5 was: 21A75C9EDCB34288E2E75596CF8430F6
 * DDR file was: mt128x64mx32_Step3.inc
 * DDR file MD5 was: E095B4E8E969E41800AF5A6E104D650C
 */
static unsigned char mt128x64mx32_Step3_commands[]={
	0xC8, 0xC8,	0xC9, 0xC9,	0x01, 0x9B,	0x02, 0x9B,
	0x03, 0x9B,	0x04, 0x9B,	0x05, 0x9B,	0x06, 0x9B,
	0x07, 0x9B,	0x08, 0x9B,	0x42, 0x1C,	0x3D, 0x00,
	0x2C, 0x06,	0x2E, 0x06,	0x29, 0x06,	0x2A, 0x06,
	0x2B, 0x06,	0x2D, 0x00,	0x2F, 0x06,	0x30, 0x06,
	0x3A, 0x06,	0x48, 0x06,	0x3B, 0x1C,	0x31, 0x13,
	0x33, 0x13,	0x27, 0x13,	0x25, 0x13,	0x24, 0x13,
	0x21, 0x13,	0x35, 0x13,	0x37, 0x13,	0x4A, 0x26,
	0x46, 0x06,	0x47, 0x06,	0x49, 0x06,	0x4B, 0x06,
	0x4C, 0x06,	0x4D, 0x06,	0x4E, 0x06,	0x39, 0x06,
	0x32, 0x06,	0x34, 0x06,	0x28, 0x06,	0x26, 0x06,
	0x23, 0x06,	0x22, 0x06,	0x36, 0x06,	0x38, 0x06,
	0x56, 0x16,	0x79, 0x16,	0x6E, 0xCA,	0x91, 0xCA,
	0x5E, 0x90,	0x81, 0xCB,	0x6F, 0x3A,	0x92, 0x3A,
	0x70, 0x0D,	0x93, 0x0D,	0x62, 0x6C,	0x63, 0x6C,
	0x64, 0x6C,	0x65, 0x6C,	0x85, 0x6C,	0x86, 0x6C,
	0x87, 0x6C,	0x88, 0x6C,	0x66, 0x97,	0x67, 0x97,
	0x68, 0x97,	0x69, 0x97,	0x89, 0x97,	0x8A, 0x97,
	0x8B, 0x97,	0x8C, 0x97,	0x6C, 0xCC,	0x8F, 0xCD,
	0x6D, 0xCE,	0x90, 0xCF,	0x6A, 0x67,	0x6B, 0x00,
	0x8D, 0x67,	0x8E, 0x00,	0x71, 0x69,	0x95, 0x69,
	0x70, 0x0D,	0x93, 0x0D,	0x52, 0xD0,	0x50, 0x1F,
	0x53, 0xD1,	0x54, 0xD2,	0x55, 0x0F,	0x58, 0x60,
	0x59, 0xD3,	0x5A, 0xD4,	0x51, 0x00,	0x5B, 0x09,
	0x4F, 0x8B,	0x75, 0xD0,	0x73, 0x1F,	0x76, 0xD1,
	0x77, 0xD2,	0x78, 0x0F,	0x7B, 0x60,	0x7C, 0xD3,
	0x7D, 0xD4,	0x74, 0x00,	0x7E, 0x02,	0x72, 0x8B,
	0x56, 0x38,	0x56, 0x98,	0x56, 0x93,	0x56, 0xD5,
	0x56, 0xD6,	0x79, 0x38,	0x79, 0x98,	0x79, 0x93,
	0x79, 0xD5,	0x79, 0xD6,	0x57, 0x10,	0x7A, 0x10,
	0x61, 0x00,	0x84, 0x00,	0x70, 0x0D,	0x93, 0x0D,
	0x50, 0x23,	0x73, 0x23,	0x5D, 0x19,	0x80, 0x19,
	0x56, 0x00,	0x79, 0x00,	0xCA, 0xD7,	0xCB, 0xD8,
	0xCC, 0xD8,	0xFF, 0xFF
};

static u32 mt128x64mx32_Step3_RamValues[]={
	/* ADDRESSES */
	0x020C4018, 0x020C4014, 0x020E0010, 0x020E0018,
	0x020E001C, 0x00000000,
	/* VALUES */
	0x00060324, 0x00018900, 0x1B5F0109, 0xA1310003,
	0x40404046, 0x42424648, 0x3A383C34, 0x40323C3C,
	0x33374133, 0x00100A82, 0x00000093, 0x009F0E10,
	0x001A0889, 0x04028030, 0x03038030, 0xF00000CF,
	0x007F007F, 0x00000000
};
/* End of automatically generated part */

int dart_mx6_eeprom_dram_init(void)
{
	struct eeprom_cfg eeprom_cfg = {0};
	int is_eeprom_valid = !(dart_mx6_eeprom_read_struct(&eeprom_cfg));
	int is_eeprom_data_correct = is_eeprom_valid;

	/*
	 * The eeprom contains commands with
	 * 1 byte index to a common address in this array, and
	 * 1 byte index to a common value in the next array - to write to the address.
	 * Some commands in the eeprom contain higher indices,
	 * to custom addresses and values which are not present in the common arrays,
	 * and it also contains an array of the custom addresses and values themselves.
	 */
	u32 custom_addresses[MAX_CUSTOM_ADDRESSES] = {0};
	u32 custom_values[MAX_CUSTOM_VALUES] = {0};

	/*
	 * The MX6Q_MMDC_LPDDR2_register_programming_aid_v0_Micron_InterL_commands
	 * revision is incorrect.
	 * If the data is equal to it, use mt128x64mx32_Step3_commands revision instead
	 */
	if (is_eeprom_valid &&
	    !memcmp(eeprom_cfg.commands,
		    MX6Q_MMDC_LPDDR2_register_programming_aid_v0_Micron_InterL_commands,
		    254))
		is_eeprom_data_correct = 0;

	dart_mx6_load_custom_data(custom_addresses, custom_values,
			is_eeprom_data_correct ?
			eeprom_cfg.custom_addresses_values:
			mt128x64mx32_Step3_RamValues);

	dart_mx6_handle_commands(is_eeprom_data_correct ?
				 eeprom_cfg.commands :
				 (struct eeprom_command *)
				 	mt128x64mx32_Step3_commands,
				 common_addresses,
				 common_values,
				 custom_addresses,
				 custom_values);

	if (is_eeprom_valid) {
		return eeprom_cfg.dram_size * 128;
	} else {
		printf("DDR LEGACY configuration\n");

		return 1024;
	}
}
